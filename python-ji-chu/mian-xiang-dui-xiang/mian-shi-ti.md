# 面试题

##  Python中可变对象和不可变对象？

不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。 

可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。 

Python 中，数值类型（int 和 float）、字符串 str、元组 tuple 都是**不可变类型**。而列表 list、字典 dict、集合 set 是**可变类型**。

## Python 中 is 和==的区别？

is 判断的是 a 对象是否就是 b 对象，是通过 id 来判断的。 

==判断的是 a 对象的值是否和 b 对象的值相等，是通过 value 来判断的。

## Python 的魔法方法

魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现 （重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。 

**\_\_init\_\_** 构造器，当一个实例被创建的时候初始化的方法。但是它并不是实例化调用的第一个方法。

**\_\_new\_\_**才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 **\_\_init\_\_**。 **\_\_new\_\_**很少使 用，但是也有它适合的场景，尤其 是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。 

**\_\_call\_\_** 允许一个类的实例像函数一样被调用 。 

**\_\_getitem\_\_** 定义获取容器中指定元素的行为，相当于 self\[key\] 。 

**\_\_getattr\_\_** 定义当用户试图访问一个不存在属性的时候的行为 。 

**\_\_setattr\_\_** 定义当一个属性被设置的时候的行为 。 

**\_\_getattribute\_\_** 定义当一个属性被访问的时候的行为 。

## 面向对象中怎么实现只读属性?

```python
class MyCls(object):
    __weight = 50

    @property #以访问属性的方式来访问 weight 方法
    def weight(self):
        return self.__weight

if __name__ == '__main__':
    obj = MyCls()
    print(obj.weight)
    obj.weight = 12
```

## 谈谈你对面向对象的理解？

面向对象是相对于面向过程而言的。

面向过程语言是一种**基于功能分析的、以算法为中心**的程序设计方法。

面向对象是一种基于结构分析的、以数据为中心的程序设计思想。在面向对象语言中有一个有很重要东西，叫做类。 

面向对象有三大特性：**封装、继承、多态**。

## Python 中类方法、类实例方法、静态方法有何区别？

**类方法**：类对象的方法，在定义时需要在上方使用“@classmethod”进行装饰，形参为 cls， 表示类对象。类对象和实例对象都可调用。

**类实例方法**：类实例化对象的方法，只有实例对象可以调用，形参为 self，指代对象本身。

**静态方法**：一个任意函数，在其上方使用“@staticmethod”进行装饰，可以用对象直接调用， 静态方法实际上跟该类没有太大关系。

## Python 中如何动态获取和设置对象的属性？

```python
if hasattr(Parent, 'x'):
    print(getattr(Parent, 'x'))
    setattr(Parent, 'x', 3)
print(getattr(Parent, 'x'))
```

