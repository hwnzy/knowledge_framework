# 滴滴高频面试题



### 2. 简述并实现工厂模式，工厂模式有什么常见问题？

工厂模式有多种实现，比较简单的一种实现称之为简单工厂模式\(Simple Factory Pattern\)。简单工厂模式又称为静态工厂方法\(Static Factory Method\)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。

将各种运算拆分成单独的类，均继承于Operation类，各运算子类重写Operation类中的GetResult\(\)方法。统一通过简单工厂类（OperationFactory类）实例化运算所需的运算子类。

这样设计的优点：

* **易扩展** 如果添加新的运算类，只需要

1. 新的运算类继承Operation类，并重写GetResult\(\)方法
2. 在简单工厂类（OperationFactory类）中添加对应的if语句

无需对其他运算类进行操作。

* **易维护** 对某一运算类进行修改，并不涉及其他运算类，很大程度上避免了由于误操作而对其他运算类修改的问题。
* **低耦合** 各运算类只公共继承Operation类，不涉及其他运算类。
* **高复用** 无论是控制台，还是windows程序，Web程序，均可使用该程序实现计算器功能。



缺点，当我们需要增加一产品，比如在计算机中加入一个新的功能，可以求M的N次方，这样个小功能我们就要去添加一个新的类，同时我们需要在Factory中改动到switch里面的代码，这是耦合性很高的表现

### 3. 简述封装、继承、多态的特性及使用场景

**封装的意义：**

1. 将属性和方法放到一起做为一个整体，然后通过实例化对象来处理；
2. 隐藏内部实现细节，只需要和对象及其属性和方法交互就可以了；
3. 对类的属性和方法增加 访问权限控制。

继承描述的是多个类之间的所属关系。类A里面的属性和方法可以复用，则可以通过继承的方式，传递到类B里。类A就是基类，也叫做父类；类B就是派生类，也叫做子类。

在需要使用父类对象的地方,也可以使用子类对象, 这种情况就叫多态.

## **\# 网络协议**

* ▲ 13 RestFul 是什么？RestFul 请求的 URL 有什么特点？

RESTful架构：

　　（1）每一个URI代表一种资源；

　　（2）客户端和服务器之间，传递这种资源的某种表现层；

　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。



* ▲ 9 简述 HTTP 1.0，1.1，2.0 的主要区别  
  见外层标题

* ▲ 6 什么是跨域，什么情况下会发生跨域请求？

跨域，指的是从一个域名去请求另外一个域名的资源。nginx代理跨域

* ▲ 6 Cookie和Session的关系和区别是什么？

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。Session 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的。

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

* ▲ 3 简述 TCP 滑动窗口以及重传机制

滑动窗口机制是TCP的一种流量控制方法，该机制允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。

超时重传

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

快速重传

![](../.gitbook/assets/image%20%2898%29.png)

所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。



* ▲ 3 TCP 中 SYN 攻击是什么？如何防止？

攻击者通常使用欺骗性IP地址向目标服务器发送大量SYN数据包。

然后，服务器响应每个连接请求，并准备好接收响应的开放端口。

当服务器等待从未到达的最终ACK数据包时，攻击者继续发送更多的SYN数据包。每个新SYN数据包的到达导致服务器暂时维持新的开放端口连接一段时间，并且一旦利用了所有可用端口，服务器就无法正常运行。

## **\# 算法**

* ▲ 11 实现快速排序

```python
def quick_sort(lists,i,j):
    if i >= j:
        return list
    pivot = lists[i]
    low = i
    high = j
    while i < j:
        while i < j and lists[j] >= pivot:
            j -= 1
        lists[i]=lists[j]
        while i < j and lists[i] <=pivot:
            i += 1
        lists[j]=lists[i]
    lists[j] = pivot
    quick_sort(lists,low,i-1)
    quick_sort(lists,i+1,high)
    return lists
```

* ▲ 8 反转链表 \(Leetcode\)

```python
def reverseList(self, head: ListNode) -> ListNode:
        if not head:
            return None
        if not head.next:
            return head
        headNode = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return headNode
```

* ▲ 8 爬楼梯 \(Leetcode\)

```python
int fib(int N) {
    vector<int> dp(N + 1, 0);
    // base case
    dp[1] = dp[2] = 1;
    for (int i = 3; i <= N; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[N];
}

def stairs(n):
        a, b = 1, 2
        for i in range(1, n+1):
            num = a
            a, b = b, a+b
        return num
```

* ▲ 8 剑指 Offer 10- II. 青蛙跳台阶问题
* ▲ 5 快速排序的空间复杂度是多少？时间复杂度的最好最坏的情况是多少，有哪些优化方案？
* ▲ 4 实现归并排序

## **\# 数据库**

* ▲ 11 联合索引的存储结构是什么？

B+树

* ▲ 6 简述 Redis 中如何防止缓存雪崩和缓存击穿

1 缓存穿透

缓存只是为了缓解数据库压力而添加的一层保护层，当从缓存中查询不到我们需要的数据就要去数据库中查询了。如果被黑客利用，频繁去访问缓存中没有的数据，那么缓存就失去了存在的意义，瞬间所有请求的压力都落在了数据库上，这样会导致数据库连接异常。

解决方案：

1. 约定:对于返回为NULL的依然缓存，对于抛出异常的返回不进行缓存,注意不要把抛异常的也给缓存了。采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。

2 缓存雪崩

缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。

1、给缓存加上一定区间内的随机生效时间，不同的key设置不同的失效时间，避免同一时间集体失效。比如以前是设置10分钟的超时时间，那每个Key都可以随机8-13分钟过期，尽量让不同Key的过期时间不同。

2、采用多级缓存，不同级别缓存设置的超时时间不同，及时某个级别缓存都过期，也有其他级别缓存兜底。  


* ▲ 3 聚簇索引和非聚簇索引有什么区别？什么情况用聚集索引？
* ▲ 3 Redis 如何实现分布式锁？

7.1.0 B+树、B-树的区别? 

\(1\) B+树改进了B树, 让内结点只作索引使用, 去掉了其中指向data record的指针, 使得每个结点中能够存放更多的key, 因此能有更大的出度. 这有什么用? 这样就意味着存放同样多的key, 树的层高能进一步被压缩, 使得检索的时间更短.

\(2\)当然了,由于底部的叶子结点是链表形式, 因此也可以实现更方便的顺序遍历, 但是这是比较次要的, 最主要的的还是第\(1\)点.

7.1.1 数据库隔离级别，幻读和不可重复读的区别？ 

7.1.2 有 hell, well, hello, world 等字符串组，现在问能否拼接成 helloworld，代码实现。

 7.1.3 快排算法实现 

7.1.4 线程安全的单例模式 

7.1.5 25 匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢， 求出第三 3 快的马要多少场比赛？ 

7.1.6 kmp 算法 next 数组的求解思路 

7.1.7 数组中有三个数字出现超过 3/4，求这三个数字？ 

7.1.8 1 到 n+2 个数组中缺了两个数，如何用 O\(n\)时间，O\(1\)空间找到这两个数字。

整个数组自我xor一遍，然后xor 1到N一遍，得到a^b（因为x xor x == 0，所以1-N，1-N去掉两个xor在一起为a^b\)，必然非零

从中选一位作为分割，比如a^b = 0b00011000,可以选分割bitmask为 0b00001000

然后对于数组每个数要么x & bitmask == 0, 要么!=0,分为两类自我xor一遍

然后1到N,也根据x & bitmask分为两类，在前面两个xor sum上继续xor一遍，两类的xor sum结果就是两个去掉的数

7.1.9 一条线段长为 1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？ 

假设我们选择的两个点的坐标是x和y（先假设x &lt; y）：   
那么由三角形两边和大于第三边的性质，有：   
x+y-x&gt;1-y   
x+1-y&gt;y-x   
1-y+y-x&gt;x

由上述不等式得到：x &lt; 0.5, 0.5 &lt; y &lt; x+0.5   
然后画个图就能得到联合概率为1/8，不要忘了这个结果是在假设x &lt; y时得来的，所以再乘以2，得到1/4。  


7.2.0 有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个 数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？ 

7.2.1 B+树做索引时，B+树通常高度为多少层？要参考哪些条件？

3-4层

答案：一个高度为 3 的 B+ 树大概可以存放 1170 × 1170 × 16 = 21902400 行数据，已经是千万级别的数据量了。



