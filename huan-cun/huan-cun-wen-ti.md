# 缓存问题

### 缓存穿透 <a id="1-&#x7F13;&#x5B58;&#x7A7F;&#x900F;"></a>

缓存只是为了缓解数据库压力而添加的一层保护层，当从缓存中查询不到我们需要的数据就要去数据库中查询了。如果被黑客利用，频繁去访问缓存中没有的数据，那么缓存就失去了存在的意义，瞬间所有请求的压力都落在了数据库上，这样会导致数据库连接异常。

解决方案：

1. 约定:**对于返回为NULL的依然缓存**，对于抛出异常的返回不进行缓存,注意不要把抛异常的也给缓存了。采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。

![](../.gitbook/assets/image%20%2840%29.png)

1. **制定一些规则过滤一些不可能存在的数据**，小数据用BitMap，大数据可以用布隆过滤器（布隆过滤器是一种数据结构， 实际上是一个很长的二进制向量和一系列随机映射函数，一个比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询），比如你的订单ID 明显是在一个范围1-1000，如果不是1-1000之内的数据那其实可以直接给过滤掉。

![](../.gitbook/assets/image%20%2829%29.png)

### 2 缓存雪崩 <a id="2-&#x7F13;&#x5B58;&#x96EA;&#x5D29;"></a>

缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。

![](../.gitbook/assets/image%20%2826%29.png)

解决方案：

1、给缓存加上一定区间内的随机生效时间，不同的key设置不同的失效时间，避免同一时间集体失效。比如以前是设置10分钟的超时时间，那每个Key都可以随机8-13分钟过期，尽量让不同Key的过期时间不同。

2、采用多级缓存，不同级别缓存设置的超时时间不同，及时某个级别缓存都过期，也有其他级别缓存兜底。

3、利用加锁或者队列方式避免过多请求同时对服务器进行读写操作。

