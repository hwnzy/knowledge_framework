# TCP和UDP

## 简述 TCP 和 UDP 的区别以及优缺点?

UDP 是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息。 

优点：UDP 速度快、操作简单、要求系统资源较少，由于通讯不需要连接，可以实现广播发送 

缺点：UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数 据是否会正确接收，也不重复发送，不可靠。

TCP 是面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手 

优点：TCP 在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠。 

缺点：TCP 相对于 UDP 速度慢一点，要求系统资源较多。

## TCP连接

![&#x5EFA;&#x7ACB;TCP&#x8FDE;&#x63A5;](../../.gitbook/assets/image%20%2879%29.png)

| seq | ack | ACK | SYN | FIN |
| :--- | :--- | :--- | :--- | :--- |
| 序号字段 | 确认号字段 | 确认位 | 同步位 | 终止位 |

1. SYN=1, seq=x
2. SYN=1, ACK=1, seq=y, ack=x+1
3. ACK=1, seq=x+1, ack=y+1

![&#x91CA;&#x653E;TCP&#x8FDE;&#x63A5;](../../.gitbook/assets/image%20%2880%29.png)

1. FIN=1, seq=u
2. ACK=1, seq=v, ack=u+1
3. FIN=1, ACK=1, seq=w, ack=u+1
4. ACK=1, seq=u+1, ack=w+1 

###  为什么不采用“两次握手”建立连接？

* 这主要是为了防止两次握手情况下已失效的连接请求报文突然又传送到服务端，而产生了错误。考虑下面情况：客户A向服务端B发送TCP连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接，而此时前一个滞留在网络中的连接请求到达了服务器B端，而B认为A又发送了请求，如果采用的两次握手，则这种情况下B认为传输连接已经建立，并一直等待A传输数据，而A此时并无连接请求，因此不理睬，这样就造成B资源的浪费。
* 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认 

### **为什么需要四次挥手？**为什么要不采用三次握手释放连接？

因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。

如果是三次挥手，会怎么样？三次的话，被动关闭端在收到FIN消息之后，需要同时回复ACK和Server端的FIN消息。如果Server端在该连接上面并没有Pending的消息要处理，那么是可以的，如果Server端还需要等待一段时间才可以关闭另外一个方向的连接，那么这样的三次挥手就不能满足条件。

### 为什么要不采用三次握手释放连接，且发送最后一次握手报文后要等待2MSL（最长报文段寿命, Maximum Segment Lifetime）的时间呢

1. 为了保证A发送的最后一个确认报文能够到达B，如果A不等待2MSL，若A返回的最后确认报文段丢失，则B不能进入正常关闭状态，而此时A已经关闭，也不可能再重传。
2. 为了防止出现“已经失效的连接请求报文”。A在发送完最后一个确认报文段后，再经过2MSL可保证本连接持续的时间内所产生的所有报文段从网络中消失。

